---
id: handle-randomness
title: How to Handle and Use Randomness On-Chain
description: "Learn how to generate and use random numbers in NEAR smart contracts, with trade-offs, alternatives, and testing, using a coin flip example."
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This tutorial explains randomness on NEAR, using a simple coin flip smart contract as an example. The full example code is available at [GitHub](https://github.com/near-examples/coin-flip-examples).

## Understanding Randomness on NEAR

Blockchain environments are deterministic, making true randomness challenging. NEAR provides a `random seed` â€“ a 32-byte array accessible in smart contracts. This seed is generated by the validator producing the block, who signs the previous block hash with their private key.

The seed is unpredictable for users submitting transactions but known to the validator. This ensures verifiability but introduces potential manipulation risks.

In practice:
- In AssemblyScript/JS: Use `near.randomSeed()` to get the byte array.
- In Rust: Use `env::random_seed()`.

## Using Randomness in a Coin Flip Example

The coin flip contract lets users guess "heads" or "tails". It uses the random seed to determine the outcome and awards points if correct.

Here's the core randomness logic:

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/src/contract.ts"
            start="31" end="41" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/src/lib.rs"
            start="52" end="60" />
  </Language>
</CodeTabs>

The first byte of the seed is modulo 2 to simulate a fair 50/50 flip. If the user's guess matches, points are incremented.

## Trade-offs and Alternatives

### Trade-offs:
- **Validator Manipulation**: Validators know the seed in advance and can:
  - Game inputs (e.g., submit favorable transactions).
  - Refuse to mine blocks with unfavorable outcomes, boosting win odds (e.g., from 50% to 75% in coin flip by skipping losses).
- This is more pronounced in binary games; multi-outcome games dilute the advantage.
- The seed is deterministic per block, so not suitable for high-stakes crypto without mitigations.

### Alternatives:
- **Two-Stage Process**: Separate "commit" (e.g., place bet) and "resolve" (reveal outcome) across blocks. This prevents input gaming but not block refusal.
- **External Oracles**: Use services like Chainlink for verifiable randomness (VRF), though it adds trust and cost.
- **Combined Seeds**: Hash multiple block seeds or user inputs for better unpredictability.
- For critical apps, avoid on-chain randomness entirely and use off-chain sources.

See NEAR's [security notes on randomness](../../smart-contracts/security/random.md) for details.

## How to Test for Randomness

Testing on-chain randomness requires simulating real conditions, as local environments use fixed seeds.

- **Integration Tests**: Deploy the contract and run multiple flips. Check for even distribution (e.g., ~50% heads/tails over 1000 runs). Example from the coin flip tests:

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="main.test.js"
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
            start="32" end="57" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="tests.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/tests/tests.rs"
            start="25" end="82" />
  </Language>
</CodeTabs>

- **Statistical Tests**: On testnet, run many transactions and apply chi-square or diehard tests on outcomes using tools like Python's scipy.
- **Edge Cases**: Test validator-like attacks by simulating block skips in custom environments.
- Note: Sandbox tests are deterministic; use testnet for pseudo-random behavior.

## Conclusion

Randomness on NEAR is accessible but requires careful design to mitigate validator risks. Start with simple uses like games, and scale to secure alternatives for production.

:::note Versioning
This tutorial is based on near-cli 4.0.13, node 18.19.1, rustc 1.77.0.
:::
